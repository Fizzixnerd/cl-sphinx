;(cl:defpackage pocketsphinx
;  (:nicknames ps))
;
;(cl:use-package :pocketsphinx)

(cl:eval-when (:compile-toplevel :load-toplevel)
  (cl:unless (cl:fboundp 'swig-lispify)
    (cl:defun pocketsphinx-lispify (name flag cl:&optional (package cl:*package*))
      (cl:labels ((helper (lst last rest cl:&aux (c (cl:car lst)))
                    (cl:cond
                      ((cl:null lst)
                       rest)
                      ((cl:upper-case-p c)
                       (helper (cl:cdr lst) 'upper
                               (cl:case last
                                 ((lower digit) (cl:list* c #\- rest))
                                 (cl:t (cl:cons c rest)))))
                      ((cl:lower-case-p c)
                       (helper (cl:cdr lst) 'lower (cl:cons (cl:char-upcase c) rest)))
                      ((cl:digit-char-p c)
                       (helper (cl:cdr lst) 'digit 
                               (cl:case last
                                 ((upper lower) (cl:list* c #\- rest))
                                 (cl:t (cl:cons c rest)))))
                      ((cl:char-equal c #\_)
                       (helper (cl:cdr lst) '_ (cl:cons #\- rest)))
                      (cl:t
                       (cl:error "Invalid character: ~A" c))))
		  (without-prefix (prefix name)
		    (cl:when (cl:string-equal prefix name
					      :end2 (cl:length prefix))
		      (cl:subseq name (cl:length prefix)))))
        (cl:let ((fix (cl:case flag
                        ((constant enumvalue) "+")
                        (variable "*")
                        (cl:t "")))
		 (postfix (cl:case flag
			    (classname "-cstruct")
			    (cl:t "")))
		 (name (without-prefix "ps_" name)))
          (cl:intern
           (cl:concatenate
            'cl:string
            fix
            (cl:nreverse (helper (cl:concatenate 'cl:list name) cl:nil cl:nil))
	    postfix
            fix)
           package))))))

(defun cfunction-p (cffi-form)
  "Return non-NIL if cffi-form is a `CFFI:DEFCFUN' form, else return NIL."
  (equal (first cffi-form) 'cffi:defcfun))

(defun cfunction-name (defcfun-form)
  "Return the name of the symbol (as a STRING) which will be used to
reference the foreign function defined in `DEFCFUN-FORM'. Signal an
error if `DEFCFUN-FORM' is not a `CFFI:DEFCFUN' form."
  (unless (cfunction-p defcfun-form)
    (error "`CFUNCTION-NAME' called on a form which is not a
    `CFFI:DEFCFUN' form."))
  (symbol-name (cadr (second defcfun-form))))

(defun method-p (cffi-form first-argument)
  "Return non-NIL if `CFFI-FORM' is a `CFFI:DEFCFUN' form and the
first argument to the foreign function is `EQUAL' to the form given as
`FIRST-ARGUMENT', else return NIL."
  (and (cfunction-p cffi-form)
       (equal (fourth cffi-form) first-argument)))

(defun decoder-method-p (cffi-form)
  "Return non-NIL if `CFFI-FORM' is a method on a Pocketsphinx
Decoder, else return NIL."
  (method-p cffi-form '(ps :decoder)))

(defun decoder-getter-p (cffi-form)
  "Return non-NIL if `CFFI-FORM' is Decoder method, and which is
referenced through a Lisp symbol whose `SYMBOL-NAME' begins with
\"GET\", else return NIL."
  (let ((method-name (cfunction-name cffi-form)))
    (and (decoder-method-p cffi-form)
	 (>= (length method-name) (length "GET"))
	 (equal (subseq method-name 0 3) "GET"))))

(defun decoder-setter-p (cffi-form)
  "Return non-NIL if `CFFI-FORM' is Decoder method, and which is
referenced through a Lisp symbol whose `SYMBOL-NAME' begins with
\"UPDATE\", else return NIL."
  (let ((method-name (cfunction-name cffi-form)))
    (and (decoder-method-p cffi-form)
	 (>= (length method-name) (length "UPDATE"))
	 (equal (subseq method-name 0 6) "UPDATE"))))

(defun segment-method-p (cffi-form)
  "Return non-NIL if `CFFI-FORM' is a method on a Pocketsphinx
Segment, else return NIL."
  (method-p cffi-form '(seg :pointer)))

(defun nbest-method-p (cffi-form)
  "Return non-NIL if `CFFI-FORM' is a method of a Pocketsphinx NBest,
else return NIL."
  (method-p cffi-form '(nbest :pointer)))

(defun symbol-without-prefix (symbol prefix)
  "Return a new symbol formed by removing the prefix designated by the
symbol `PREFIX' from the symbol `SYMBOL'."
  (let ((symbol-name-length (length (symbol-name symbol)))
	(prefix-name-length (length (symbol-name prefix)))
	(symbol-name-string (symbol-name symbol))
	(prefix-name-string (symbol-name prefix)))
    (if (and (>= symbol-name-length prefix-name-length)
	     (equal (subseq symbol-name-string 0 prefix-name-length)
		    prefix-name-string))
	(intern (subseq symbol-name-string prefix-name-length))
	;; else
	symbol)))

(defun n-cfunction-arguments (defcfun-form)
  ;; Tested and seems to work.
  "Return the number of arguments required by the foreign function
defined by `defcfun-form'. Signal an error if defcfun-form is not a
`cffi:defcfun' form."
  (unless (cfunction-p defcfun-form)
    (error "`N-CFUNCTION-ARGUMENTS' called on a form which is not a
    `CFFI:DEFCFUN' form."))
  (length (cdddr defcfun-form)))

(defun parse-cffi-output (filename)
  (with-open-file
      (cffi-file filename :direction :input)
    (loop
       for form = (read cffi-file nil :eof-error)
       while (not (equal form :eof-error))
	 ;; Find and sort through all the functions.
         if (decoder-method-p form)
           if (decoder-getter-p form)
             collect form into decoder-getters
           else if (decoder-setter-p form)
             collect form into decoder-setters
           else
             collect form into decoder-other-methods
         else if (and (cfunction-p form)
		      (equal (cfunction-name form) "INIT"))
           collect form into decoder-initializer
       
         else if (segment-method-p form)
           collect form into segment-methods

         else if (nbest-method-p form)
           collect form into nbest-methods

	 else if (and (cfunction-p form)
		      (equal (cfunction-name form) "ARGS"))
	   collect form into args-function

	 else if (cfunction-p form)
	   collect form into other-functions
       
       finally
         (return (list decoder-getters decoder-setters
		       decoder-other-methods decoder-initializer
		       segment-methods nbest-methods args-function
		       other-functions)))))

(defmacro define-config-class ())

(defmacro define-decoder-class (decoder-getters decoder-setters
				decoder-other-methods
				decoder-initializer)
  '(defclass decoder ()
    ((foreign-decoder-pointer
      :documentation "Foreign pointer to the C decoder object.")))

  '(defmethod initialize-instance :after ((ps-decoder decoder) (decoder-config config))
    (with-slots (foreign-decoder-pointer) decoder
      (setf foreign-decoder-pointer (init decoder-config))))
     
  (loop
     for defcfun-form in decoder-getters
     and defcfun-name = (cfunction-name defcfun-form)
     and getter-method-name = (symbol-without-prefix (cfunction-name defcfun-form) 'get-)
       ;; some decoder 'get-' defcfuns require more than one argument
       ;; (ie, `GET-HYP' and friends).
       ;; FIXME: Make sure to deal with the special cases for > 1
       ;;        arguments.
     (when (= (n-cfunction-arguments defcfun-form) 1)
       ;; evaluate the definition of the defcfun-form
       defcfun-form
       ;; then define a method using it
       `(defmethod ,getter-method-name ((ps-decoder decoder))
	  (with-slots ((foreign-decoder-pointer)) ps-decoder
	    (,defcfun-name foreign-decoder-pointer)))
       ;; export the method
       `(export ,getter-method-name))))
